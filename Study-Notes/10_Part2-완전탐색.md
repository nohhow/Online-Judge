# Part2-완전탐색
## 완전탐색
존재하는 모든 경우의 수를 모두 살펴보면서 답을 찾는 탐색방법

### 장점
* 반드시 답을 찾을 수 있다.
	* 전부 살펴봤는데 답이 없는 경우? 답이 존재하지 않다는 사실을 알아낸 것!

### 단점
* 오래 걸린다.
	* 리소스 소모가 크다.

> **trade-off 관계 : 컴퓨팅 자원 <-> 시간**  
* 컴퓨터 성능, 용량을 많이 투입할 것인가?
* 시간을 많이 투입할 것인가? 
* 어느 한 쪽이 커지면 다른 쪽은 작아진다. (반비례 관계)

PS 환경은 컴퓨터 자원이 한정적이기 때문에 얼마나 오래걸리는지 **시간**을 고려하는 것이 중요하다.

> 완전 탐색 방법론을 사용하는 알고리즘은 여러 가지가 있는데, 각 각 살펴본다.  

## 브루트 포스 Brute-force 무차별 대입

> **비밀번호 숫자 4자리 풀기**  
경우의 수 10^4 = 10000 (0000~9999) 를 전부 대입해보면 컴퓨터 연산 속도로는 금방 뚫을 수 있다.
보안 강화를 위해서는 비밀번호 자릿수를 늘리거나 한 자릿수에 들어갈 수 있는 문자 수를 늘려야한다.

무식한 방법처럼 보이지만  
가장 확실한 방법이기 때문에 의외로 많이 쓰인다.

* 암호학, 수학 등 학계에서도, PS에서도 널리 쓰이는 알고리즘이다.
* 4색정리 증명에도 쓰였다.
* 보안이 허술한 곳은 진짜 이러한 방법으로 계정 탈취가 가능할 수 있다.


## 완전탐색으로 풀 수 있을까?

## 문제 1
* 문제 : N개의 수를 입력 받아서 두 수를 뽑아 합이 가장 클 때는?
* 시간제한 : 1초
* 입력 : 2 <= N <= 1,000,000

이 경우에는 N에 입력되는 수를 최악으로 두고 시간 복잡도를 파악해보아야하는데,
시간복잡도는 $O(N^2)$
이에 1,000,000을 대입해보면 $(10^6)^2$ 가 된다.

시간제한은 1초이고, 1초에 약 1억 번의 연산이 가능하다고 봤을 때, 이를 훨씬 초과하기에 **완전탐색으로 풀이할 수 없는 문제라고 인지할 수 있어야 한다.**


### 풀이

완전탐색으로는 풀이가 불가능하기 때문에 다른 방법을 고안해야하는데,
N을 sort하고 처리하는 방법을 생각해본다.

그럼 가장 큰 수가 index 기준 마지막, 마지막-1 에 위치할 것이다.

<mark>일반적인 정렬의 시간 복잡도 : $O(NlogN)$ </mark>

1,000,000을 이에 대입해보면 1억보다 작은 수가 나온다.


- - - -



## 순열 permutation

* 모든 경우의 수를 순서대로 살펴볼 때 용이하다.
* 삼성에서 next_permutation을 활용하면 쉽게 풀리는 문제들이 많이 나왔다고 한다.

`n! / (n-r)!`

C++에서 구현할 때는 정렬된 배열을 사용해야함.


### python으로 구현시
```python
from itertools import permutations

v= [0, 1, 2, 3]

for i in permutations(v,4):
	print(i)
```

permutations의 인자가 2개인데, 첫 번째 인자는 대상, 두 번째 인자는 뽑을 갯수이다.

## 조합 combination
n! / (n-r)! r!

파이썬에서 기본 제공 C++은 없음

```python
from itertools import combinations

v = [0, 1, 2, 3]

for i in combination(v,2):
	print(i)
```
